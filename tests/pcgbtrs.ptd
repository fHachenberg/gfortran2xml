
        Namespace: A-H: (REAL 4) I-N: (INTEGER 4) O-Z: (REAL 4)
        procedure name = pcgbtrs
        symtree: idum3  Ambig 0
        symbol idum3 (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: clacpy  Ambig 0
        symbol clacpy (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: b  Ambig 0
        symbol b (COMPLEX 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION DUMMY)
        Array spec:(1 AS_ASSUMED_SIZE 1 () )

        symtree: aptr  Ambig 0
        symbol aptr (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: a  Ambig 0
        symbol a (COMPLEX 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION DUMMY)
        Array spec:(1 AS_ASSUMED_SIZE 1 () )

        symtree: af  Ambig 0
        symbol af (COMPLEX 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION DUMMY)
        Array spec:(1 AS_ASSUMED_SIZE 1 () )

        symtree: blacs_gridinfo  Ambig 0
        symbol blacs_gridinfo (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS EXTERNAL-PROC EXTERNAL SUBROUTINE)

        symtree: bignum  Ambig 0
        symbol bignum (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 10000

        symtree: bbptr  Ambig 0
        symbol bbptr (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: blacs_gridexit  Ambig 0
        symbol blacs_gridexit (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: bm  Ambig 0
        symbol bm (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: block_cyclic_2d  Ambig 0
        symbol block_cyclic_2d (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 1

        symtree: ccopy  Ambig 0
        symbol ccopy (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: bwu  Ambig 0
        symbol bwu (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: bw  Ambig 0
        symbol bw (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: bn  Ambig 0
        symbol bn (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: bmn  Ambig 0
        symbol bmn (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: bnn  Ambig 0
        symbol bnn (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: bwl  Ambig 0
        symbol bwl (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: cgetrs  Ambig 0
        symbol cgetrs (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: cgesd2d  Ambig 0
        symbol cgesd2d (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: cgemm  Ambig 0
        symbol cgemm (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: cgeru  Ambig 0
        symbol cgeru (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: cgemv  Ambig 0
        symbol cgemv (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: cgerv2d  Ambig 0
        symbol cgerv2d (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: claswp  Ambig 0
        symbol claswp (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: descb_px1  Ambig 0
        symbol descb_px1 (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION)
        Array spec:(1 AS_EXPLICIT 1 7 )

        symtree: cone  Ambig 0
        symbol cone (COMPLEX 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: (complex 0.1e1 0.e0)

        symtree: czero  Ambig 0
        symbol czero (COMPLEX 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: (complex 0.e0 0.e0)

        symtree: cswap  Ambig 0
        symbol cswap (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: csrc  Ambig 0
        symbol csrc (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: cscal  Ambig 0
        symbol cscal (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: csrc_  Ambig 0
        symbol csrc_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 8

        symtree: ctrsm  Ambig 0
        symbol ctrsm (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)

        symtree: ctxt_  Ambig 0
        symbol ctxt_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 2

        symtree: desc_convert  Ambig 0
        symbol desc_convert (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS EXTERNAL-PROC EXTERNAL SUBROUTINE)

        symtree: desca_1xp  Ambig 0
        symbol desca_1xp (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION)
        Array spec:(1 AS_EXPLICIT 1 7 )

        symtree: desca  Ambig 0
        symbol desca (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION DUMMY)
        Array spec:(1 AS_ASSUMED_SIZE 1 () )

        symtree: descb  Ambig 0
        symbol descb (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION DUMMY)
        Array spec:(1 AS_ASSUMED_SIZE 1 () )

        symtree: globchk  Ambig 0
        symbol globchk (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS EXTERNAL-PROC EXTERNAL SUBROUTINE)

        symtree: descmult  Ambig 0
        symbol descmult (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 100

        symtree: dlen_  Ambig 0
        symbol dlen_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 9

        symtree: dtype_  Ambig 0
        symbol dtype_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 1

        symtree: first_proc  Ambig 0
        symbol first_proc (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: ictxt_new  Ambig 0
        symbol ictxt_new (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: ichar  Ambig 0
        symbol ichar (INTEGER 4)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC INTRINSIC FUNCTION IMPLICIT-TYPE)
        result: ichar

        symtree: ib  Ambig 0
        symbol ib (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: ictxt  Ambig 0
        symbol ictxt (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: ictxt_save  Ambig 0
        symbol ictxt_save (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: idum2  Ambig 0
        symbol idum2 (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: lbwu  Ambig 0
        symbol lbwu (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: j  Ambig 0
        symbol j (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: ipiv  Ambig 0
        symbol ipiv (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION DUMMY)
        Array spec:(1 AS_ASSUMED_SIZE 1 () )

        symtree: int_one  Ambig 0
        symbol int_one (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 1

        symtree: info  Ambig 0
        symbol info (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: ja_new  Ambig 0
        symbol ja_new (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: ja  Ambig 0
        symbol ja (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: l  Ambig 0
        symbol l (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: lbwl  Ambig 0
        symbol lbwl (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: laf  Ambig 0
        symbol laf (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: mod  Ambig 0
        symbol mod (INTEGER 4)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC INTRINSIC FUNCTION IMPLICIT-TYPE)
        result: mod

        symtree: lptr  Ambig 0
        symbol lptr (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: lmj  Ambig 0
        symbol lmj (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: llda  Ambig 0
        symbol llda (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: ldbb  Ambig 0
        symbol ldbb (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: lld_  Ambig 0
        symbol lld_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 9

        symtree: ldw  Ambig 0
        symbol ldw (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: lldb  Ambig 0
        symbol lldb (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: lm  Ambig 0
        symbol lm (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: ln  Ambig 0
        symbol ln (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: mb_  Ambig 0
        symbol mb_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 5

        symtree: m_  Ambig 0
        symbol m_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 3

        symtree: lsame  Ambig 0
        symbol lsame (LOGICAL 4)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS EXTERNAL-PROC EXTERNAL FUNCTION)
        result: lsame

        symtree: lwork  Ambig 0
        symbol lwork (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: max  Ambig 0
        symbol max (INTEGER 4)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC FUNCTION IMPLICIT-TYPE)
        result: max

        symtree: min  Ambig 0
        symbol min (INTEGER 4)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC FUNCTION IMPLICIT-TYPE)
        result: min

        symtree: store_m_b  Ambig 0
        symbol store_m_b (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: numroc  Ambig 0
        symbol numroc (INTEGER 4)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS EXTERNAL-PROC EXTERNAL FUNCTION)
        result: numroc

        symtree: nb  Ambig 0
        symbol nb (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: n  Ambig 0
        symbol n (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: myrow  Ambig 0
        symbol myrow (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: mycol  Ambig 0
        symbol mycol (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: n_  Ambig 0
        symbol n_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 4

        symtree: neicol  Ambig 0
        symbol neicol (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: nb_  Ambig 0
        symbol nb_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 6

        symtree: np_save  Ambig 0
        symbol np_save (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: np  Ambig 0
        symbol np (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: nprow  Ambig 0
        symbol nprow (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: npcol  Ambig 0
        symbol npcol (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: npact  Ambig 0
        symbol npact (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: npstr  Ambig 0
        symbol npstr (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: nrhs  Ambig 0
        symbol nrhs (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: return_code  Ambig 0
        symbol return_code (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: reshape  Ambig 0
        symbol reshape (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS EXTERNAL-PROC EXTERNAL SUBROUTINE)

        symtree: param_check  Ambig 0
        symbol param_check (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION)
        Array spec:(2 AS_EXPLICIT 1 17 1 3 )

        symtree: odd_size  Ambig 0
        symbol odd_size (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: one  Ambig 0
        symbol one (REAL 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 0.1e1

        symtree: pcgbtrs  Ambig 0
        symbol pcgbtrs (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC SUBROUTINE)
        Formal arglist: trans n bwl bwu nrhs a ja desca ipiv b ib descb af laf work lwork info

        symtree: part_offset  Ambig 0
        symbol part_offset (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: pxerbla  Ambig 0
        symbol pxerbla (UNKNOWN 0)(PROCEDURE UNKNOWN-INTENT UNKNOWN-ACCESS EXTERNAL-PROC EXTERNAL SUBROUTINE)

        symtree: recovery_val  Ambig 0
        symbol recovery_val (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: rsrc_  Ambig 0
        symbol rsrc_ (INTEGER 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 7

        symtree: zero  Ambig 0
        symbol zero (REAL 4)(PARAMETER UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)
        value: 0.e0

        symtree: wptr  Ambig 0
        symbol wptr (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: work  Ambig 0
        symbol work (COMPLEX 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DIMENSION DUMMY)
        Array spec:(1 AS_ASSUMED_SIZE 1 () )

        symtree: store_n_a  Ambig 0
        symbol store_n_a (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)

        symtree: trans  Ambig 0
        symbol trans (CHARACTER 1)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC DUMMY)

        symtree: work_size_min  Ambig 0
        symbol work_size_min (INTEGER 4)(VARIABLE UNKNOWN-INTENT UNKNOWN-ACCESS UNKNOWN-PROC)


      ASSIGN info 0
      ASSIGN desca_1xp(1) 501
      ASSIGN descb_px1(1) 502
      CALL desc_convert ((desca(FULL)) (desca_1xp(FULL)) (return_code))
      IF (<> return_code 0)
        ASSIGN info -802
      ENDIF
      CALL desc_convert ((descb(FULL)) (descb_px1(FULL)) (return_code))
      IF (<> return_code 0)
        ASSIGN info -1102
      ENDIF
      IF (<> desca_1xp(2) descb_px1(2))
        ASSIGN info -1102
      ENDIF
      IF (<> desca_1xp(4) descb_px1(4))
        ASSIGN info -1104
      ENDIF
      IF (<> desca_1xp(5) descb_px1(5))
        ASSIGN info -1105
      ENDIF
      ASSIGN ictxt desca_1xp(2)
      ASSIGN csrc desca_1xp(5)
      ASSIGN nb desca_1xp(4)
      ASSIGN llda desca_1xp(6)
      ASSIGN store_n_a desca_1xp(3)
      ASSIGN lldb descb_px1(6)
      ASSIGN store_m_b descb_px1(3)
      CALL blacs_gridinfo ((ictxt) (nprow) (npcol) (myrow) (mycol))
      ASSIGN np (* nprow npcol)
      IF lsame[[((trans) ('N'))]]
        ASSIGN idum2 78
      ELSE IF lsame[[((trans) ('C'))]]
        ASSIGN idum2 67
      ELSE
        ASSIGN info -1
      ENDIF
      IF (< lwork -1)
        ASSIGN info -16
      ELSE IF (= lwork -1)
        ASSIGN idum3 -1
      ELSE
        ASSIGN idum3 1
      ENDIF
      IF (< n 0)
        ASSIGN info -2
      ENDIF
      IF (> (- (+ n ja) 1) store_n_a)
        ASSIGN info -806
      ENDIF
      IF (OR (> bwl (- n 1)) (< bwl 0))
        ASSIGN info -3
      ENDIF
      IF (OR (> bwu (- n 1)) (< bwu 0))
        ASSIGN info -4
      ENDIF
      IF (< llda (+ (+ (* 2 bwl) (* 2 bwu)) 1))
        ASSIGN info -806
      ENDIF
      IF (<= nb 0)
        ASSIGN info -804
      ENDIF
      ASSIGN bw (+ bwu bwl)
      IF (> (- (+ n ib) 1) store_m_b)
        ASSIGN info -1103
      ENDIF
      IF (< lldb nb)
        ASSIGN info -1106
      ENDIF
      IF (< nrhs 0)
        ASSIGN info -5
      ENDIF
      IF (<> ja ib)
        ASSIGN info -7
      ENDIF
      IF (<> nprow 1)
        ASSIGN info -802
      ENDIF
      IF (> n (- (* np nb) __mod_i4[[(((- ja 1)) (nb))]]))
        ASSIGN info -2
        CALL pxerbla ((ictxt) ('PCGBTRS, D&C alg.: only 1 block per proc') ((U- info)))
        RETURN 
      ENDIF
      IF (AND (> (- (+ ja n) 1) nb) (< nb (+ (+ bwl bwu) 1)))
        ASSIGN info -804
        CALL pxerbla ((ictxt) ('PCGBTRS, D&C alg.: NB too small') ((U- info)))
        RETURN 
      ENDIF
      ASSIGN work_size_min (* nrhs (+ (+ nb (* 2 bwl)) (* 4 bwu)))
      ASSIGN work(1) __convert_i4_c4[[((work_size_min))]]
      IF (< lwork work_size_min)
        IF (<> lwork -1)
          ASSIGN info -16
          CALL pxerbla ((ictxt) ('PCGBTRS: worksize error ') ((U- info)))
        ENDIF
        RETURN 
      ENDIF
      ASSIGN param_check(17 , 1) descb(5)
      ASSIGN param_check(16 , 1) descb(4)
      ASSIGN param_check(15 , 1) descb(3)
      ASSIGN param_check(14 , 1) descb(2)
      ASSIGN param_check(13 , 1) descb(1)
      ASSIGN param_check(12 , 1) ib
      ASSIGN param_check(11 , 1) desca(5)
      ASSIGN param_check(10 , 1) desca(4)
      ASSIGN param_check(9 , 1) desca(3)
      ASSIGN param_check(8 , 1) desca(1)
      ASSIGN param_check(7 , 1) ja
      ASSIGN param_check(6 , 1) nrhs
      ASSIGN param_check(5 , 1) bwu
      ASSIGN param_check(4 , 1) bwl
      ASSIGN param_check(3 , 1) n
      ASSIGN param_check(2 , 1) idum3
      ASSIGN param_check(1 , 1) idum2
      ASSIGN param_check(17 , 2) 1105
      ASSIGN param_check(16 , 2) 1104
      ASSIGN param_check(15 , 2) 1103
      ASSIGN param_check(14 , 2) 1102
      ASSIGN param_check(13 , 2) 1101
      ASSIGN param_check(12 , 2) 10
      ASSIGN param_check(11 , 2) 805
      ASSIGN param_check(10 , 2) 804
      ASSIGN param_check(9 , 2) 803
      ASSIGN param_check(8 , 2) 801
      ASSIGN param_check(7 , 2) 7
      ASSIGN param_check(6 , 2) 5
      ASSIGN param_check(5 , 2) 4
      ASSIGN param_check(4 , 2) 3
      ASSIGN param_check(3 , 2) 2
      ASSIGN param_check(2 , 2) 16
      ASSIGN param_check(1 , 2) 1
      IF (>= info 0)
        ASSIGN info 10000
      ELSE IF (< info -100)
        ASSIGN info (U- info)
      ELSE
        ASSIGN info (U- (* info 100))
      ENDIF
      CALL globchk ((ictxt) (17) (param_check(FULL)) (17) (param_check(1 , 3)) (info))
      IF (= info 10000)
        ASSIGN info 0
      ELSE IF (= __mod_i4[[((info) (100))]] 0)
        ASSIGN info (U- (/ info 100))
      ELSE
        ASSIGN info (U- info)
      ENDIF
      IF (< info 0)
        CALL pxerbla ((ictxt) ('PCGBTRS') ((U- info)))
        RETURN 
      ENDIF
      IF (= n 0)
        RETURN 
      ENDIF
      IF (= nrhs 0)
        RETURN 
      ENDIF
      ASSIGN part_offset (* nb (/ (- ja 1) (* npcol nb)))
      IF (< (- mycol csrc) (/ (- (- ja part_offset) 1) nb))
        ASSIGN part_offset (+ part_offset nb)
      ENDIF
      IF (< mycol csrc)
        ASSIGN part_offset (- part_offset nb)
      ENDIF
      ASSIGN first_proc __mod_i4[[(((+ (/ (- ja 1) nb) csrc)) (npcol))]]
      ASSIGN ja_new (+ __mod_i4[[(((- ja 1)) (nb))]] 1)
      ASSIGN np_save np
      ASSIGN np (+ (/ (- (+ ja_new n) 2) nb) 1)
      CALL reshape ((ictxt) (1) (ictxt_new) (1) (first_proc) (1) (np))
      ASSIGN ictxt_save ictxt
      ASSIGN ictxt ictxt_new
      ASSIGN desca_1xp(2) ictxt_new
      ASSIGN descb_px1(2) ictxt_new
      CALL blacs_gridinfo ((ictxt) (nprow) (npcol) (myrow) (mycol))
      IF (< myrow 0)
        GOTO 1234
      ENDIF
      IF (< mycol (- npcol 1))
        CALL cgesd2d ((ictxt) (bwu) (nrhs) (b((+ (- nb bwu) 1))) (lldb) (0) ((+ mycol 1)))
      ENDIF
      IF (< mycol (- npcol 1))
        ASSIGN lm (- nb bwu)
      ELSE
        ASSIGN lm nb
      ENDIF
      IF (> mycol 0)
        ASSIGN wptr (+ bwu 1)
      ELSE
        ASSIGN wptr 1
      ENDIF
      ASSIGN ldw (+ (+ (+ nb bwu) (* 2 bw)) bwu)
      CALL clacpy (('G') (lm) (nrhs) (b(1)) (lldb) (work(wptr)) (ldw))
      DO j=1 nrhs 1
        DO l=(+ wptr lm) ldw 1
          ASSIGN work((+ (* (- j 1) ldw) l)) (complex 0.e0 0.e0)
1502      CONTINUE
        END DO
1501    CONTINUE
      END DO
      IF (> mycol 0)
        CALL cgerv2d ((ictxt) (bwu) (nrhs) (work(1)) (ldw) (0) ((- mycol 1)))
      ENDIF
      ASSIGN odd_size numroc[[((n) (nb) (mycol) (0) (npcol))]]
      IF (<> mycol 0)
        ASSIGN lbwl bw
        ASSIGN lbwu 0
        ASSIGN aptr 1
      ELSE
        ASSIGN lbwl bwl
        ASSIGN lbwu bwu
        ASSIGN aptr (+ 1 bwu)
      ENDIF
      IF (<> mycol (- npcol 1))
        ASSIGN lm (- nb lbwu)
        ASSIGN ln (- nb bw)
      ELSE IF (<> mycol 0)
        ASSIGN lm (+ odd_size bwu)
        ASSIGN ln __max_i4[[(((- odd_size bw)) (0))]]
      ELSE
        ASSIGN lm n
        ASSIGN ln __max_i4[[(((- n bw)) (0))]]
      ENDIF
      DO j=1 ln 1
        ASSIGN lmj __min_i4[[((lbwl) ((- lm j)))]]
        ASSIGN l ipiv(j)
        IF (<> l j)
          CALL cswap ((nrhs) (work(l)) (ldw) (work(j)) (ldw))
        ENDIF
        ASSIGN lptr (+ (+ (+ bw 1) (* (- j 1) llda)) aptr)
        CALL cgeru ((lmj) (nrhs) ((complex -0.1e1 0.e0)) (a(lptr)) (1) (work(j)) (ldw) (work((+ j 1))) (ldw))
21      CONTINUE
      END DO
      IF (<> mycol (- npcol 1))
        ASSIGN bm (- bw lbwu)
        ASSIGN bn bw
      ELSE
        ASSIGN bm (+ __min_i4[[((bw) (odd_size))]] bwu)
        ASSIGN bn __min_i4[[((bw) (odd_size))]]
      ENDIF
      ASSIGN bbptr (+ (* (+ nb bwu) bw) 1)
      ASSIGN ldbb (+ (* 2 bw) bwu)
      IF (= npcol 1)
        CALL cgetrs (('N') ((- n ln)) (nrhs) (af((+ bbptr (* bw ldbb)))) (ldbb) (ipiv((+ ln 1))) (work((+ ln 1))) (ldw) (info))
      ENDIF
      ASSIGN npact npcol
      ASSIGN npstr 1
200   IF (<= npact 1)
        GOTO 300
      ENDIF
      IF (= __mod_i4[[((mycol) (npstr))]] 0)
        IF (= __mod_i4[[((mycol) ((* 2 npstr)))]] 0)
          ASSIGN neicol (+ mycol npstr)
          IF (<= (/ neicol npstr) (- npact 1))
            IF (< (/ neicol npstr) (- npact 1))
              ASSIGN bmn bw
            ELSE
              ASSIGN bmn (+ __min_i4[[((bw) (numroc[[((n) (nb) (neicol) (0) (npcol))]]))]] bwu)
            ENDIF
            CALL cgesd2d ((ictxt) (bm) (nrhs) (work((+ ln 1))) (ldw) (0) (neicol))
            IF (<> npact 2)
              CALL cgerv2d ((ictxt) ((- (+ bm bmn) bw)) (nrhs) (work((+ ln 1))) (ldw) (0) (neicol))
              ASSIGN bm (- (+ bm bmn) bw)
            ENDIF
          ENDIF
        ELSE
          ASSIGN neicol (- mycol npstr)
          IF (= neicol 0)
            ASSIGN bmn (- bw bwu)
          ELSE
            ASSIGN bmn bw
          ENDIF
          CALL clacpy (('G') (bm) (nrhs) (work((+ ln 1))) (ldw) (work((+ (+ (+ nb bwu) bmn) 1))) (ldw))
          CALL cgerv2d ((ictxt) (bmn) (nrhs) (work((+ (+ nb bwu) 1))) (ldw) (0) (neicol))
          IF (<> npact 2)
            CALL claswp ((nrhs) (work((+ (+ nb bwu) 1))) (ldw) (1) (bw) (ipiv((+ ln 1))) (1))
            CALL ctrsm (('L') ('L') ('N') ('U') (bw) (nrhs) ((complex 0.1e1 0.e0)) (af((+ bbptr (* bw ldbb)))) (ldbb) (work((+ (+ nb bwu) 1))) (ldw))
            CALL cgemm (('N') ('N') ((- (+ bm bmn) bw)) (nrhs) (bw) ((complex -0.1e1 0.e0)) (af((+ (+ bbptr (* bw ldbb)) bw))) (ldbb) (work((+ (+ nb bwu) 1))) (ldw) ((complex 0.1e1 0.e0)) (work((+ (+ (+ nb bwu) 1) bw))) (ldw))
            CALL cgesd2d ((ictxt) ((- (+ bm bmn) bw)) (nrhs) (work((+ (+ (+ nb bwu) 1) bw))) (ldw) (0) (neicol))
          ELSE
            CALL claswp ((nrhs) (work((+ (+ nb bwu) 1))) (ldw) (1) ((+ bm bmn)) (ipiv((+ ln 1))) (1))
            CALL ctrsm (('L') ('L') ('N') ('U') ((+ bm bmn)) (nrhs) ((complex 0.1e1 0.e0)) (af((+ bbptr (* bw ldbb)))) (ldbb) (work((+ (+ nb bwu) 1))) (ldw))
          ENDIF
        ENDIF
        ASSIGN npact (/ (+ npact 1) 2)
        ASSIGN npstr (* npstr 2)
        GOTO 200
      ENDIF
300   CONTINUE
      IF (= npcol 1)
      ENDIF
      ASSIGN recovery_val (- (* npact npstr) npcol)
2200  IF (>= npact npcol)
        GOTO 2300
      ENDIF
      ASSIGN npstr (/ npstr 2)
      ASSIGN npact (* npact 2)
      ASSIGN npact (- npact __mod_i4[[(((/ recovery_val npstr)) (2))]])
      IF (< (/ mycol npstr) (- npact 1))
        ASSIGN bn bw
      ELSE
        ASSIGN bn __min_i4[[((bw) (numroc[[((n) (nb) ((- npcol 1)) (0) (npcol))]]))]]
      ENDIF
      IF (= __mod_i4[[((mycol) ((* 2 npstr)))]] 0)
        ASSIGN neicol (+ mycol npstr)
        IF (<= (/ neicol npstr) (- npact 1))
          IF (< (/ neicol npstr) (- npact 1))
            ASSIGN bmn bw
            ASSIGN bnn bw
          ELSE
            ASSIGN bmn (+ __min_i4[[((bw) (numroc[[((n) (nb) (neicol) (0) (npcol))]]))]] bwu)
            ASSIGN bnn __min_i4[[((bw) (numroc[[((n) (nb) (neicol) (0) (npcol))]]))]]
          ENDIF
          IF (> npact 2)
            CALL cgesd2d ((ictxt) ((* 2 bw)) (nrhs) (work((+ ln 1))) (ldw) (0) (neicol))
            CALL cgerv2d ((ictxt) (bw) (nrhs) (work((+ ln 1))) (ldw) (0) (neicol))
          ELSE
            CALL cgerv2d ((ictxt) (bw) (nrhs) (work((+ ln 1))) (ldw) (0) (neicol))
          ENDIF
        ENDIF
      ELSE
        ASSIGN neicol (- mycol npstr)
        IF (= neicol 0)
          ASSIGN bmn (- bw bwu)
        ELSE
          ASSIGN bmn bw
        ENDIF
        IF (< neicol (- npcol 1))
          ASSIGN bnn bw
        ELSE
          ASSIGN bnn __min_i4[[((bw) (numroc[[((n) (nb) (neicol) (0) (npcol))]]))]]
        ENDIF
        IF (> npact 2)
          CALL clacpy (('G') (bw) (nrhs) (work((+ (+ nb bwu) 1))) (ldw) (work((+ (+ (+ nb bwu) bw) 1))) (ldw))
          CALL cgerv2d ((ictxt) ((* 2 bw)) (nrhs) (work((+ ln 1))) (ldw) (0) (neicol))
          CALL cgemm (('N') ('N') (bw) (nrhs) (bn) ((complex -0.1e1 0.e0)) (af(bbptr)) (ldbb) (work((+ ln 1))) (ldw) ((complex 0.1e1 0.e0)) (work((+ (+ (+ nb bwu) bw) 1))) (ldw))
          IF (> mycol npstr)
            CALL cgemm (('N') ('N') (bw) (nrhs) (bw) ((complex -0.1e1 0.e0)) (af((+ bbptr (* (* 2 bw) ldbb)))) (ldbb) (work((+ (+ ln bw) 1))) (ldw) ((complex 0.1e1 0.e0)) (work((+ (+ (+ nb bwu) bw) 1))) (ldw))
          ENDIF
          CALL ctrsm (('L') ('U') ('N') ('N') (bw) (nrhs) ((complex 0.1e1 0.e0)) (af((+ bbptr (* bw ldbb)))) (ldbb) (work((+ (+ (+ nb bwu) bw) 1))) (ldw))
          CALL cgesd2d ((ictxt) (bw) (nrhs) (work((+ (+ (+ nb bwu) bw) 1))) (ldw) (0) (neicol))
          CALL clacpy (('G') (bw) (nrhs) (work((+ (+ (+ nb bwu) 1) bw))) (ldw) (work((+ (+ ln bw) 1))) (ldw))
        ELSE
          CALL ctrsm (('L') ('U') ('N') ('N') ((+ bn bnn)) (nrhs) ((complex 0.1e1 0.e0)) (af((+ bbptr (* bw ldbb)))) (ldbb) (work((+ (+ nb bwu) 1))) (ldw))
          CALL cgesd2d ((ictxt) (bw) (nrhs) (work((+ (+ nb bwu) 1))) (ldw) (0) (neicol))
          CALL clacpy (('G') ((- (+ bnn bn) bw)) (nrhs) (work((+ (+ (+ nb bwu) 1) bw))) (ldw) (work((+ ln 1))) (ldw))
          IF (<> (+ (+ nb bwu) 1) (+ (+ ln 1) bw))
            DO j=1 bw 1
              CALL ccopy ((nrhs) (work((+ (+ nb bwu) j))) (ldw) (work((+ (+ ln bw) j))) (ldw))
1064          CONTINUE
            END DO
          ENDIF
        ENDIF
      ENDIF
      GOTO 2200
2300  CONTINUE
      IF (<> mycol (- npcol 1))
        ASSIGN bm (- bw lbwu)
      ELSE
        ASSIGN bm (+ __min_i4[[((bw) (odd_size))]] bwu)
      ENDIF
      IF (< mycol (- npcol 1))
        CALL cgesd2d ((ictxt) (bw) (nrhs) (work((+ (- nb bw) 1))) (ldw) (0) ((+ mycol 1)))
      ENDIF
      IF (> mycol 0)
        CALL cgerv2d ((ictxt) (bw) (nrhs) (work((+ (+ nb bwu) 1))) (ldw) (0) ((- mycol 1)))
        CALL cgemm (('N') ('N') ((- lm bm)) (nrhs) (bw) ((complex -0.1e1 0.e0)) (af(1)) (lm) (work((+ (+ nb bwu) 1))) (ldw) ((complex 0.1e1 0.e0)) (work(1)) (ldw))
      ENDIF
      DO j=ln 1 -1
        ASSIGN lmj __min_i4[[((bw) ((- odd_size 1)))]]
        ASSIGN lptr (+ (+ (- bw 1) (* j llda)) aptr)
        CALL cgemv (('T') (lmj) (nrhs) ((complex -0.1e1 0.e0)) (work((+ j 1))) (ldw) (a(lptr)) ((- llda 1)) ((complex 0.1e1 0.e0)) (work(j)) (ldw))
        CALL cscal ((nrhs) ((/ (complex 0.1e1 0.e0) a((+ (- lptr llda) 1)))) (work(j)) (ldw))
2021    CONTINUE
      END DO
      CALL clacpy (('G') (odd_size) (nrhs) (work(1)) (ldw) (b(1)) (lldb))
      ASSIGN ictxt ictxt_save
      IF (<> ictxt ictxt_new)
        CALL blacs_gridexit ((ictxt_new))
      ENDIF
1234  CONTINUE
      ASSIGN np np_save
      ASSIGN work(1) __convert_i4_c4[[((work_size_min))]]
      RETURN 

